{"remainingRequest":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/guest/Ostanin-dev/static/lib/v-calendar/src/components/Grid.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/src/components/Grid.vue","mtime":1592351795000},{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\nconst directions = {\n  vLeading: 'vertical-leading',\n  vTrailing: 'vertical-trailing',\n  hLeading: 'horizontal-leading',\n  hTrailing: 'horizontal-trailing',\n};\nexport default {\n  name: 'Grid',\n  render(h) {\n    // Grid cell renderer\n    const getCell = ({ nodes, position, row, column }) => {\n      // Get the default slot first\n      if (nodes.length >= position) {\n        return nodes[position - 1];\n      }\n      // Get the scoped slot second\n      if (this.$scopedSlots.default) {\n        return this.$scopedSlots.default({\n          position,\n          row,\n          column,\n        });\n      }\n      return null;\n    };\n\n    // Grid cells renderer\n    const getCells = () => {\n      const cells = [];\n      // Resolve default slot nodes (remove whitespaced)\n      const nodes =\n        (this.$slots.default &&\n          this.$slots.default.filter(n => n.tag !== undefined)) ||\n        [];\n      // Build cells\n      for (let r = 1, p = 1; r <= this.rows; r++) {\n        for (let c = 1; c <= this.columns; c++) {\n          const rFromEnd = r - this.rows - 1;\n          const cFromEnd = c - this.columns - 1;\n          // Add the cell for current row & column\n          cells.push(\n            h(\n              'div',\n              {\n                class: [\n                  'vc-grid-cell',\n                  `vc-grid-cell-row-${r}`,\n                  `vc-grid-cell-row-${rFromEnd}`,\n                  `vc-grid-cell-col-${c}`,\n                  `vc-grid-cell-col-${cFromEnd}`,\n                ],\n                style: {\n                  'grid-row': r,\n                  'grid-column': c,\n                },\n                on: {\n                  keydown: e =>\n                    this.handleCellKeydown({ row: r, column: c, event: e }),\n                },\n              },\n              [getCell({ nodes, position: p++, row: r, column: c })],\n            ),\n          );\n        }\n      }\n      return cells;\n    };\n\n    return h(\n      'div',\n      {\n        class: 'vc-grid-container',\n        style: this.containerStyle,\n      },\n      [...getCells()],\n    );\n  },\n  props: {\n    count: Number,\n    rows: {\n      type: Number,\n      default: 1,\n    },\n    columns: {\n      type: Number,\n      default: 1,\n    },\n    gap: {\n      type: String,\n      default: '0px',\n    },\n    autofit: Boolean,\n    columnWidth: {\n      type: String,\n      default: '1fr',\n    },\n    disableFocus: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  computed: {\n    containerStyle() {\n      return {\n        gridTemplateColumns: this.gridTemplateColumns,\n        gridGap: this.gap,\n      };\n    },\n    gridTemplateColumns() {\n      return `repeat(${this.autofit ? 'auto-fit' : this.columns}, ${\n        this.columnWidth\n      })`;\n    },\n  },\n  methods: {\n    handleCellKeydown({ row, column, event }) {\n      // Return if focus management is disabled\n      if (this.disableFocus) return;\n      const state = {\n        row,\n        column,\n        alt: false,\n        handled: false,\n      };\n      // Increment row/column based on key\n      switch (event.key) {\n        case 'ArrowUp': {\n          state.row--;\n          break;\n        }\n        case 'ArrowDown': {\n          state.row++;\n          break;\n        }\n        case 'ArrowLeft': {\n          state.column--;\n          break;\n        }\n        case 'ArrowRight': {\n          state.column++;\n          break;\n        }\n        case 'Home': {\n          state.column = 1;\n          break;\n        }\n        case 'End': {\n          state.column = this.columns;\n          break;\n        }\n        case 'PageUp': {\n          state.alt = event.altKey;\n          state.direction = directions.vLeading;\n          break;\n        }\n        case 'PageDown': {\n          state.alt = event.altKey;\n          state.direction = directions.vTrailing;\n          break;\n        }\n        default: {\n          return;\n        }\n      }\n      // Handle state for row rollovers\n      if (state.row < 1) {\n        state.direction = directions.vLeading;\n        state.row = this.rows;\n      } else if (state.row > this.rows) {\n        state.direction = directions.vTrailing;\n        state.row = 1;\n      }\n      // Handle state for column rollovers\n      if (state.column < 1) {\n        state.direction = directions.hLeading;\n        state.column = this.columns;\n      } else if (state.column > this.columns) {\n        state.direction = directions.hTrailing;\n        state.column = 1;\n      }\n      // Emit rollover event if direction was assigned\n      if (state.direction) {\n        this.$emit('rollover', state);\n      }\n      // Focusd on cell for current state if event wasn't handled\n      if (!state.handled) {\n        // Get grid cell element\n        const cellSelector = `.vc-grid-cell-row-${state.row}.vc-grid-cell-col-${state.column}`;\n        const cellEl = this.$el.querySelector(cellSelector);\n        if (cellEl) {\n          this.tryFocus(cellEl);\n        }\n      }\n      event.stopPropagation();\n      event.preventDefault();\n    },\n    tryFocus(el = this.$el) {\n      this.$nextTick(() => {\n        const selectors = [\n          '.vc-grid-focus',\n          'button, [href], input, select, textarea, [tabindex=\"0\"]',\n          '[tabindex]:not([tabindex=\"undefined\"])',\n        ];\n        const focusableEl = selectors\n          .map(s => el.querySelector(s))\n          .find(e => e);\n        if (focusableEl) {\n          focusableEl.focus();\n          return true;\n        }\n        return false;\n      });\n    },\n  },\n};\n",{"version":3,"sources":["Grid.vue"],"names":[],"mappings":";AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Grid.vue","sourceRoot":"src/components","sourcesContent":["<script>\nconst directions = {\n  vLeading: 'vertical-leading',\n  vTrailing: 'vertical-trailing',\n  hLeading: 'horizontal-leading',\n  hTrailing: 'horizontal-trailing',\n};\nexport default {\n  name: 'Grid',\n  render(h) {\n    // Grid cell renderer\n    const getCell = ({ nodes, position, row, column }) => {\n      // Get the default slot first\n      if (nodes.length >= position) {\n        return nodes[position - 1];\n      }\n      // Get the scoped slot second\n      if (this.$scopedSlots.default) {\n        return this.$scopedSlots.default({\n          position,\n          row,\n          column,\n        });\n      }\n      return null;\n    };\n\n    // Grid cells renderer\n    const getCells = () => {\n      const cells = [];\n      // Resolve default slot nodes (remove whitespaced)\n      const nodes =\n        (this.$slots.default &&\n          this.$slots.default.filter(n => n.tag !== undefined)) ||\n        [];\n      // Build cells\n      for (let r = 1, p = 1; r <= this.rows; r++) {\n        for (let c = 1; c <= this.columns; c++) {\n          const rFromEnd = r - this.rows - 1;\n          const cFromEnd = c - this.columns - 1;\n          // Add the cell for current row & column\n          cells.push(\n            h(\n              'div',\n              {\n                class: [\n                  'vc-grid-cell',\n                  `vc-grid-cell-row-${r}`,\n                  `vc-grid-cell-row-${rFromEnd}`,\n                  `vc-grid-cell-col-${c}`,\n                  `vc-grid-cell-col-${cFromEnd}`,\n                ],\n                style: {\n                  'grid-row': r,\n                  'grid-column': c,\n                },\n                on: {\n                  keydown: e =>\n                    this.handleCellKeydown({ row: r, column: c, event: e }),\n                },\n              },\n              [getCell({ nodes, position: p++, row: r, column: c })],\n            ),\n          );\n        }\n      }\n      return cells;\n    };\n\n    return h(\n      'div',\n      {\n        class: 'vc-grid-container',\n        style: this.containerStyle,\n      },\n      [...getCells()],\n    );\n  },\n  props: {\n    count: Number,\n    rows: {\n      type: Number,\n      default: 1,\n    },\n    columns: {\n      type: Number,\n      default: 1,\n    },\n    gap: {\n      type: String,\n      default: '0px',\n    },\n    autofit: Boolean,\n    columnWidth: {\n      type: String,\n      default: '1fr',\n    },\n    disableFocus: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  computed: {\n    containerStyle() {\n      return {\n        gridTemplateColumns: this.gridTemplateColumns,\n        gridGap: this.gap,\n      };\n    },\n    gridTemplateColumns() {\n      return `repeat(${this.autofit ? 'auto-fit' : this.columns}, ${\n        this.columnWidth\n      })`;\n    },\n  },\n  methods: {\n    handleCellKeydown({ row, column, event }) {\n      // Return if focus management is disabled\n      if (this.disableFocus) return;\n      const state = {\n        row,\n        column,\n        alt: false,\n        handled: false,\n      };\n      // Increment row/column based on key\n      switch (event.key) {\n        case 'ArrowUp': {\n          state.row--;\n          break;\n        }\n        case 'ArrowDown': {\n          state.row++;\n          break;\n        }\n        case 'ArrowLeft': {\n          state.column--;\n          break;\n        }\n        case 'ArrowRight': {\n          state.column++;\n          break;\n        }\n        case 'Home': {\n          state.column = 1;\n          break;\n        }\n        case 'End': {\n          state.column = this.columns;\n          break;\n        }\n        case 'PageUp': {\n          state.alt = event.altKey;\n          state.direction = directions.vLeading;\n          break;\n        }\n        case 'PageDown': {\n          state.alt = event.altKey;\n          state.direction = directions.vTrailing;\n          break;\n        }\n        default: {\n          return;\n        }\n      }\n      // Handle state for row rollovers\n      if (state.row < 1) {\n        state.direction = directions.vLeading;\n        state.row = this.rows;\n      } else if (state.row > this.rows) {\n        state.direction = directions.vTrailing;\n        state.row = 1;\n      }\n      // Handle state for column rollovers\n      if (state.column < 1) {\n        state.direction = directions.hLeading;\n        state.column = this.columns;\n      } else if (state.column > this.columns) {\n        state.direction = directions.hTrailing;\n        state.column = 1;\n      }\n      // Emit rollover event if direction was assigned\n      if (state.direction) {\n        this.$emit('rollover', state);\n      }\n      // Focusd on cell for current state if event wasn't handled\n      if (!state.handled) {\n        // Get grid cell element\n        const cellSelector = `.vc-grid-cell-row-${state.row}.vc-grid-cell-col-${state.column}`;\n        const cellEl = this.$el.querySelector(cellSelector);\n        if (cellEl) {\n          this.tryFocus(cellEl);\n        }\n      }\n      event.stopPropagation();\n      event.preventDefault();\n    },\n    tryFocus(el = this.$el) {\n      this.$nextTick(() => {\n        const selectors = [\n          '.vc-grid-focus',\n          'button, [href], input, select, textarea, [tabindex=\"0\"]',\n          '[tabindex]:not([tabindex=\"undefined\"])',\n        ];\n        const focusableEl = selectors\n          .map(s => el.querySelector(s))\n          .find(e => e);\n        if (focusableEl) {\n          focusableEl.focus();\n          return true;\n        }\n        return false;\n      });\n    },\n  },\n};\n</script>\n\n<style scoped>\n.vc-grid-container {\n  position: relative;\n  flex-shrink: 1;\n  display: grid;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\n.vc-grid-cell {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n</style>\n"]}]}