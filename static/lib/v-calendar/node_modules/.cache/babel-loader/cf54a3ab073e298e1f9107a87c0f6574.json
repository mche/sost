{"remainingRequest":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/thread-loader/dist/cjs.js!/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/babel-loader/lib/index.js!/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/eslint-loader/index.js??ref--13-0!/home/guest/Ostanin-dev/static/lib/v-calendar/src/utils/dateInfo.js","dependencies":[{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/src/utils/dateInfo.js","mtime":1592351795000},{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { addDays } from 'date-fns';\nimport { mixinOptionalProps } from './helpers';\nimport { isDate, isObject, isArray, isFunction } from './_';\nimport Locale from './locale';\nconst millisecondsPerDay = 24 * 60 * 60 * 1000;\nexport default class DateInfo {\n  constructor(config, {\n    order = 0,\n    locale = new Locale()\n  } = {}) {\n    this.isDateInfo = true;\n    this.isRange = isObject(config) || isFunction(config);\n    this.isDate = !this.isRange;\n    this.order = order;\n    this.locale = locale;\n    this.mask = locale.masks.data;\n    this.getMonthComps = locale.getMonthComps;\n    this.firstDayOfWeek = locale.firstDayOfWeek;\n    this.opts = {\n      order,\n      locale\n    }; // Process date\n\n    if (this.isDate) {\n      this.type = 'date'; // Initialize date from config\n\n      let date = this.toDate(config); // Can't accept invalid dates\n\n      date = isDate(date) ? date : new Date(); // Strip date time\n\n      date.setHours(0, 0, 0, 0); // date.setUTCHours(0, 0, 0, 0);\n      // Assign date\n\n      this.date = date;\n      this.dateTime = date.getTime();\n    } // Process date range\n\n\n    if (this.isRange) {\n      this.type = 'range'; // Date config is a function\n\n      if (isFunction(config)) {\n        this.on = {\n          and: config\n        }; // Date config is an object\n      } else {\n        // Initialize start and end dates (null means infinity)\n        let start = this.toDate(config.start);\n        let end = this.toDate(config.end); // Reconfigure start and end dates if needed\n\n        if (start && end && start > end) {\n          const temp = start;\n          start = end;\n          end = temp;\n        } else if (start && config.span >= 1) {\n          end = addDays(start, config.span - 1);\n        } // Reset invalid dates to null and strip times for valid dates\n\n\n        if (start) {\n          if (!isDate(start)) start = null;else start.setHours(0, 0, 0, 0); // else start.setUTCHours(0, 0, 0, 0);\n        }\n\n        if (end) {\n          if (!isDate(end)) end = null;else end.setHours(0, 0, 0, 0); // else end.setUTCHours(0, 0, 0, 0);\n        } // Assign start and end dates\n\n\n        this.start = start;\n        this.end = end;\n        this.startTime = start && start.getTime();\n        this.endTime = end && end.getTime(); // Assign spans\n\n        if (start && end) {\n          this.daySpan = this.diffInDays(start, end);\n          this.weekSpan = this.diffInWeeks(start, end);\n          this.monthSpan = this.diffInMonths(start, end);\n          this.yearSpan = this.diffInYears(start, end);\n        } // Assign 'and' condition\n\n\n        const andOpt = mixinOptionalProps(config, {}, DateInfo.patternProps);\n\n        if (andOpt.assigned) {\n          this.on = {\n            and: andOpt.target\n          };\n        } // Assign 'or' conditions\n\n\n        if (config.on) {\n          const or = (isArray(config.on) ? config.on : [config.on]).map(o => {\n            if (isFunction(o)) return o;\n            const opt = mixinOptionalProps(o, {}, DateInfo.patternProps);\n            return opt.assigned ? opt.target : null;\n          }).filter(o => o);\n          if (or.length) this.on = { ...this.on,\n            or\n          };\n        }\n      } // Assign flag if date is complex\n\n\n      this.isComplex = !!this.on;\n    }\n  }\n\n  toDate(date) {\n    const mask = this.locale.masks.data;\n    return this.locale.toDate(date, mask);\n  }\n\n  toDateInfo(date) {\n    return date.isDateInfo ? date : new DateInfo(date, this.opts);\n  }\n\n  startOfWeek(date) {\n    const day = date.getDay() + 1;\n    const daysToAdd = day >= this.firstDayOfWeek ? this.firstDayOfWeek - day : -(7 - (this.firstDayOfWeek - day));\n    return addDays(date, daysToAdd);\n  }\n\n  diffInDays(d1, d2) {\n    return Math.round((d2 - d1) / millisecondsPerDay);\n  }\n\n  diffInWeeks(d1, d2) {\n    return this.diffInDays(this.startOfWeek(d1), this.startOfWeek(d2));\n  }\n\n  diffInYears(d1, d2) {\n    return d2.getUTCFullYear() - d1.getUTCFullYear();\n  }\n\n  diffInMonths(d1, d2) {\n    return this.diffInYears(d1, d2) * 12 + (d2.getMonth() - d1.getMonth());\n  }\n\n  static get patterns() {\n    return {\n      dailyInterval: {\n        test: (day, interval, di) => di.diffInDays(di.start || new Date(), day.date) % interval === 0\n      },\n      weeklyInterval: {\n        test: (day, interval, di) => di.diffInWeeks(di.start || new Date(), day.date) % interval === 0\n      },\n      monthlyInterval: {\n        test: (day, interval, di) => di.diffInMonths(di.start || new Date(), day.date) % interval === 0\n      },\n      yearlyInterval: {\n        test: () => (day, interval, di) => di.diffInYears(di.start || new Date(), day.date) % interval === 0\n      },\n      days: {\n        validate: days => isArray(days) ? days : [parseInt(days, 10)],\n        test: (day, days) => days.includes(day.day) || days.includes(-day.dayFromEnd)\n      },\n      weekdays: {\n        validate: weekdays => isArray(weekdays) ? weekdays : [parseInt(weekdays, 10)],\n        test: (day, weekdays) => weekdays.includes(day.weekday)\n      },\n      ordinalWeekdays: {\n        validate: ordinalWeekdays => Object.keys(ordinalWeekdays).reduce((obj, ck) => {\n          const weekdays = ordinalWeekdays[ck];\n          if (!weekdays) return obj;\n          obj[ck] = isArray(weekdays) ? weekdays : [parseInt(weekdays, 10)];\n          return obj;\n        }, {}),\n        test: (day, ordinalWeekdays) => Object.keys(ordinalWeekdays).map(k => parseInt(k, 10)).find(k => ordinalWeekdays[k].includes(day.weekday) && (k === day.weekdayOrdinal || k === -day.weekdayOrdinalFromEnd))\n      },\n      weekends: {\n        validate: config => config,\n        test: day => day.weekday === 1 || day.weekday === 7\n      },\n      workweek: {\n        validate: config => config,\n        test: day => day.weekday >= 2 && day.weekday <= 6\n      },\n      weeks: {\n        validate: weeks => isArray(weeks) ? weeks : [parseInt(weeks, 10)],\n        test: (day, weeks) => weeks.includes(day.week) || weeks.includes(-day.weekFromEnd)\n      },\n      months: {\n        validate: months => isArray(months) ? months : [parseInt(months, 10)],\n        test: (day, months) => months.includes(day.month)\n      },\n      years: {\n        validate: years => isArray(years) ? years : [parseInt(years, 10)],\n        test: (day, years) => years.includes(day.year)\n      }\n    };\n  }\n\n  static get patternProps() {\n    return Object.keys(DateInfo.patterns).map(k => ({\n      name: k,\n      validate: DateInfo.patterns[k].validate\n    }));\n  }\n\n  static testConfig(config, day, dateInfo) {\n    if (isFunction(config)) return config(day);\n\n    if (isObject(config)) {\n      return Object.keys(config).every(k => DateInfo.patterns[k].test(day, config[k], dateInfo));\n    }\n\n    return null;\n  }\n\n  iterateDatesInRange({\n    start,\n    end\n  }, func) {\n    if (!start || !end || !isFunction(func)) return null;\n    const state = {\n      i: 0,\n      date: start,\n      day: this.locale.getDayFromDate(start),\n      finished: false\n    };\n    let result = null;\n\n    for (; !state.finished && state.date <= end; state.i++) {\n      result = func(state);\n      state.date = addDays(state.date, 1);\n      state.day = this.locale.getDayFromDate(state.date);\n    }\n\n    return result;\n  }\n\n  shallowIntersectingRange(other) {\n    return this.rangeShallowIntersectingRange(this, other);\n  } // Returns a date range that intersects two DateInfo objects\n  // NOTE: This is a shallow calculation (does not take patterns into account),\n  //   so this method should only really be called for special conditions\n  //   where absolute accuracy is not necessarily needed\n\n\n  rangeShallowIntersectingRange(date1, date2) {\n    date1 = this.toDateInfo(date1);\n    date2 = this.toDateInfo(date2);\n\n    if (!this.dateShallowIntersectsDate(date1, date2)) {\n      return null;\n    }\n\n    const thisRange = date1.toRange();\n    const otherRange = date2.toRange(); // Start with infinite start and end dates\n\n    let start = null;\n    let end = null; // This start date exists\n\n    if (thisRange.start) {\n      // Use this definite start date if other start date is infinite\n      if (!otherRange.start) {\n        start = thisRange.start;\n      } else {\n        // Otherwise, use the latest start date\n        start = thisRange.start > otherRange.start ? thisRange.start : otherRange.start;\n      } // Other start date exists\n\n    } else if (otherRange.start) {\n      // Use other definite start date as this one is infinite\n      start = otherRange.start;\n    } // This end date exists\n\n\n    if (thisRange.end) {\n      // Use this definite end date if other end date is infinite\n      if (!otherRange.end) {\n        end = thisRange.end;\n      } else {\n        // Otherwise, use the earliest end date\n        end = thisRange.end < otherRange.end ? thisRange.end : otherRange.end;\n      } // Other end date exists\n\n    } else if (otherRange.end) {\n      // Use other definite end date as this one is infinite\n      end = otherRange.end;\n    } // Return calculated range\n\n\n    return {\n      start,\n      end\n    };\n  } // ========================================================\n  // Determines if this date partially intersects another date\n  // NOTE: This is a deep test (patterns tested)\n\n\n  intersectsDate(other) {\n    const date = this.toDateInfo(other);\n    if (!this.shallowIntersectsDate(date)) return null;\n    if (!this.on) return this;\n    const range = this.rangeShallowIntersectingRange(this, date);\n    let result = false;\n    this.iterateDatesInRange(range, state => {\n      if (this.matchesDay(state.day)) {\n        result = result || date.matchesDay(state.day);\n        state.finished = result;\n      }\n    });\n    return result;\n  } // ========================================================\n  // Determines if this date partially intersects another date\n  // NOTE: This is a shallow test (no patterns tested)\n\n\n  shallowIntersectsDate(other) {\n    return this.dateShallowIntersectsDate(this, this.toDateInfo(other));\n  } // ========================================================\n  // Determines if first date partially intersects second date\n  // NOTE: This is a shallow test (no patterns tested)\n\n\n  dateShallowIntersectsDate(date1, date2) {\n    if (date1.isDate) {\n      return date2.isDate ? date1.dateTime === date2.dateTime : this.dateShallowIncludesDate(date2, date1);\n    }\n\n    if (date2.isDate) {\n      return this.dateShallowIncludesDate(date1, date2);\n    } // Both ranges\n\n\n    if (date1.start && date2.end && date1.start > date2.end) {\n      return false;\n    }\n\n    if (date1.end && date2.start && date1.end < date2.start) {\n      return false;\n    }\n\n    return true;\n  } // ========================================================\n  // Determines if this date completely includes another date\n  // NOTE: This is a deep test (patterns tested)\n\n\n  includesDate(other) {\n    const date = this.toDateInfo(other);\n\n    if (!this.shallowIncludesDate(date)) {\n      return false;\n    }\n\n    if (!this.on) {\n      return true;\n    }\n\n    const range = this.rangeShallowIntersectingRange(this, date);\n    let result = true;\n    this.iterateDatesInRange(range, state => {\n      if (this.matchesDay(state.day)) {\n        result = result && date.matchesDay(state.day);\n        state.finished = !result;\n      }\n    });\n    return result;\n  } // ========================================================\n  // Determines if this date completely includes another date\n  // NOTE: This is a shallow test (no patterns tested)\n\n\n  shallowIncludesDate(other) {\n    return this.dateShallowIncludesDate(this, other.isDate ? other : new DateInfo(other, this.opts));\n  } // ========================================================\n  // Determines if first date completely includes second date\n  // NOTE: This is a shallow test (no patterns tested)\n\n\n  dateShallowIncludesDate(date1, date2) {\n    // First date is simple date\n    if (date1.isDate) {\n      if (date2.isDate) {\n        return date1.dateTime === date2.dateTime;\n      }\n\n      if (!date2.startTime || !date2.endTime) {\n        return false;\n      }\n\n      return date1.dateTime === date2.startTime && date1.dateTime === date2.endTime;\n    } // Second date is simple date and first is date range\n\n\n    if (date2.isDate) {\n      if (date1.start && date2.date < date1.start) {\n        return false;\n      }\n\n      if (date1.end && date2.date > date1.end) {\n        return false;\n      }\n\n      return true;\n    } // Both dates are date ranges\n\n\n    if (date1.start && (!date2.start || date2.start < date1.start)) {\n      return false;\n    }\n\n    if (date1.end && (!date2.end || date2.end > date1.end)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  includesDay(day) {\n    // Date is outside general range - return null\n    if (!this.shallowIncludesDate(day.date)) return null; // Return this date if patterns match\n\n    return this.matchesDay(day) ? this : null;\n  }\n\n  matchesDay(day) {\n    // No patterns to test\n    if (!this.on) return true; // Fail if 'and' condition fails\n\n    if (this.on.and && !DateInfo.testConfig(this.on.and, day, this)) {\n      return false;\n    } // Fail if every 'or' condition fails\n\n\n    if (this.on.or && !this.on.or.some(or => DateInfo.testConfig(or, day, this))) {\n      return false;\n    } // Patterns match\n\n\n    return true;\n  }\n\n  toRange() {\n    if (this.isDate) {\n      return new DateInfo({\n        start: this.date,\n        end: this.date\n      }, this.opts);\n    }\n\n    return new DateInfo({\n      start: this.start,\n      end: this.end\n    }, this.opts);\n  } // Build the 'compare to other' function\n\n\n  compare(other) {\n    if (this.order !== other.order) return this.order - other.order;\n    if (this.type !== other.type) return this.isDate ? 1 : -1;\n    if (this.isDate) return 0;\n    const diff = this.start - other.start;\n    return diff !== 0 ? diff : this.end - other.end;\n  }\n\n}",{"version":3,"sources":["/home/guest/Ostanin-dev/static/lib/v-calendar/src/utils/dateInfo.js"],"names":["addDays","mixinOptionalProps","isDate","isObject","isArray","isFunction","Locale","millisecondsPerDay","DateInfo","constructor","config","order","locale","isDateInfo","isRange","mask","masks","data","getMonthComps","firstDayOfWeek","opts","type","date","toDate","Date","setHours","dateTime","getTime","on","and","start","end","temp","span","startTime","endTime","daySpan","diffInDays","weekSpan","diffInWeeks","monthSpan","diffInMonths","yearSpan","diffInYears","andOpt","patternProps","assigned","target","or","map","o","opt","filter","length","isComplex","toDateInfo","startOfWeek","day","getDay","daysToAdd","d1","d2","Math","round","getUTCFullYear","getMonth","patterns","dailyInterval","test","interval","di","weeklyInterval","monthlyInterval","yearlyInterval","days","validate","parseInt","includes","dayFromEnd","weekdays","weekday","ordinalWeekdays","Object","keys","reduce","obj","ck","k","find","weekdayOrdinal","weekdayOrdinalFromEnd","weekends","workweek","weeks","week","weekFromEnd","months","month","years","year","name","testConfig","dateInfo","every","iterateDatesInRange","func","state","i","getDayFromDate","finished","result","shallowIntersectingRange","other","rangeShallowIntersectingRange","date1","date2","dateShallowIntersectsDate","thisRange","toRange","otherRange","intersectsDate","shallowIntersectsDate","range","matchesDay","dateShallowIncludesDate","includesDate","shallowIncludesDate","includesDay","some","compare","diff"],"mappings":"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","sourcesContent":["import { addDays } from 'date-fns';\nimport { mixinOptionalProps } from './helpers';\nimport { isDate, isObject, isArray, isFunction } from './_';\nimport Locale from './locale';\n\nconst millisecondsPerDay = 24 * 60 * 60 * 1000;\n\nexport default class DateInfo {\n  constructor(config, { order = 0, locale = new Locale() } = {}) {\n    this.isDateInfo = true;\n    this.isRange = isObject(config) || isFunction(config);\n    this.isDate = !this.isRange;\n    this.order = order;\n    this.locale = locale;\n    this.mask = locale.masks.data;\n    this.getMonthComps = locale.getMonthComps;\n    this.firstDayOfWeek = locale.firstDayOfWeek;\n    this.opts = { order, locale };\n    // Process date\n    if (this.isDate) {\n      this.type = 'date';\n      // Initialize date from config\n      let date = this.toDate(config);\n      // Can't accept invalid dates\n      date = isDate(date) ? date : new Date();\n      // Strip date time\n      date.setHours(0, 0, 0, 0);\n      // date.setUTCHours(0, 0, 0, 0);\n      // Assign date\n      this.date = date;\n      this.dateTime = date.getTime();\n    }\n    // Process date range\n    if (this.isRange) {\n      this.type = 'range';\n      // Date config is a function\n      if (isFunction(config)) {\n        this.on = { and: config };\n        // Date config is an object\n      } else {\n        // Initialize start and end dates (null means infinity)\n        let start = this.toDate(config.start);\n        let end = this.toDate(config.end);\n        // Reconfigure start and end dates if needed\n        if (start && end && start > end) {\n          const temp = start;\n          start = end;\n          end = temp;\n        } else if (start && config.span >= 1) {\n          end = addDays(start, config.span - 1);\n        }\n        // Reset invalid dates to null and strip times for valid dates\n        if (start) {\n          if (!isDate(start)) start = null;\n          else start.setHours(0, 0, 0, 0);\n          // else start.setUTCHours(0, 0, 0, 0);\n        }\n        if (end) {\n          if (!isDate(end)) end = null;\n          else end.setHours(0, 0, 0, 0);\n          // else end.setUTCHours(0, 0, 0, 0);\n        }\n        // Assign start and end dates\n        this.start = start;\n        this.end = end;\n        this.startTime = start && start.getTime();\n        this.endTime = end && end.getTime();\n        // Assign spans\n        if (start && end) {\n          this.daySpan = this.diffInDays(start, end);\n          this.weekSpan = this.diffInWeeks(start, end);\n          this.monthSpan = this.diffInMonths(start, end);\n          this.yearSpan = this.diffInYears(start, end);\n        }\n        // Assign 'and' condition\n        const andOpt = mixinOptionalProps(config, {}, DateInfo.patternProps);\n        if (andOpt.assigned) {\n          this.on = { and: andOpt.target };\n        }\n        // Assign 'or' conditions\n        if (config.on) {\n          const or = (isArray(config.on) ? config.on : [config.on])\n            .map(o => {\n              if (isFunction(o)) return o;\n              const opt = mixinOptionalProps(o, {}, DateInfo.patternProps);\n              return opt.assigned ? opt.target : null;\n            })\n            .filter(o => o);\n          if (or.length) this.on = { ...this.on, or };\n        }\n      }\n      // Assign flag if date is complex\n      this.isComplex = !!this.on;\n    }\n  }\n\n  toDate(date) {\n    const mask = this.locale.masks.data;\n    return this.locale.toDate(date, mask);\n  }\n\n  toDateInfo(date) {\n    return date.isDateInfo ? date : new DateInfo(date, this.opts);\n  }\n\n  startOfWeek(date) {\n    const day = date.getDay() + 1;\n    const daysToAdd =\n      day >= this.firstDayOfWeek\n        ? this.firstDayOfWeek - day\n        : -(7 - (this.firstDayOfWeek - day));\n    return addDays(date, daysToAdd);\n  }\n\n  diffInDays(d1, d2) {\n    return Math.round((d2 - d1) / millisecondsPerDay);\n  }\n\n  diffInWeeks(d1, d2) {\n    return this.diffInDays(this.startOfWeek(d1), this.startOfWeek(d2));\n  }\n\n  diffInYears(d1, d2) {\n    return d2.getUTCFullYear() - d1.getUTCFullYear();\n  }\n\n  diffInMonths(d1, d2) {\n    return this.diffInYears(d1, d2) * 12 + (d2.getMonth() - d1.getMonth());\n  }\n\n  static get patterns() {\n    return {\n      dailyInterval: {\n        test: (day, interval, di) =>\n          di.diffInDays(di.start || new Date(), day.date) % interval === 0,\n      },\n      weeklyInterval: {\n        test: (day, interval, di) =>\n          di.diffInWeeks(di.start || new Date(), day.date) % interval === 0,\n      },\n      monthlyInterval: {\n        test: (day, interval, di) =>\n          di.diffInMonths(di.start || new Date(), day.date) % interval === 0,\n      },\n      yearlyInterval: {\n        test: () => (day, interval, di) =>\n          di.diffInYears(di.start || new Date(), day.date) % interval === 0,\n      },\n      days: {\n        validate: days => (isArray(days) ? days : [parseInt(days, 10)]),\n        test: (day, days) =>\n          days.includes(day.day) || days.includes(-day.dayFromEnd),\n      },\n      weekdays: {\n        validate: weekdays =>\n          isArray(weekdays) ? weekdays : [parseInt(weekdays, 10)],\n        test: (day, weekdays) => weekdays.includes(day.weekday),\n      },\n      ordinalWeekdays: {\n        validate: ordinalWeekdays =>\n          Object.keys(ordinalWeekdays).reduce((obj, ck) => {\n            const weekdays = ordinalWeekdays[ck];\n            if (!weekdays) return obj;\n            obj[ck] = isArray(weekdays) ? weekdays : [parseInt(weekdays, 10)];\n            return obj;\n          }, {}),\n        test: (day, ordinalWeekdays) =>\n          Object.keys(ordinalWeekdays)\n            .map(k => parseInt(k, 10))\n            .find(\n              k =>\n                ordinalWeekdays[k].includes(day.weekday) &&\n                (k === day.weekdayOrdinal || k === -day.weekdayOrdinalFromEnd),\n            ),\n      },\n      weekends: {\n        validate: config => config,\n        test: day => day.weekday === 1 || day.weekday === 7,\n      },\n      workweek: {\n        validate: config => config,\n        test: day => day.weekday >= 2 && day.weekday <= 6,\n      },\n      weeks: {\n        validate: weeks => (isArray(weeks) ? weeks : [parseInt(weeks, 10)]),\n        test: (day, weeks) =>\n          weeks.includes(day.week) || weeks.includes(-day.weekFromEnd),\n      },\n      months: {\n        validate: months => (isArray(months) ? months : [parseInt(months, 10)]),\n        test: (day, months) => months.includes(day.month),\n      },\n      years: {\n        validate: years => (isArray(years) ? years : [parseInt(years, 10)]),\n        test: (day, years) => years.includes(day.year),\n      },\n    };\n  }\n\n  static get patternProps() {\n    return Object.keys(DateInfo.patterns).map(k => ({\n      name: k,\n      validate: DateInfo.patterns[k].validate,\n    }));\n  }\n\n  static testConfig(config, day, dateInfo) {\n    if (isFunction(config)) return config(day);\n    if (isObject(config)) {\n      return Object.keys(config).every(k =>\n        DateInfo.patterns[k].test(day, config[k], dateInfo),\n      );\n    }\n    return null;\n  }\n\n  iterateDatesInRange({ start, end }, func) {\n    if (!start || !end || !isFunction(func)) return null;\n    const state = {\n      i: 0,\n      date: start,\n      day: this.locale.getDayFromDate(start),\n      finished: false,\n    };\n    let result = null;\n    for (; !state.finished && state.date <= end; state.i++) {\n      result = func(state);\n      state.date = addDays(state.date, 1);\n      state.day = this.locale.getDayFromDate(state.date);\n    }\n    return result;\n  }\n\n  shallowIntersectingRange(other) {\n    return this.rangeShallowIntersectingRange(this, other);\n  }\n\n  // Returns a date range that intersects two DateInfo objects\n  // NOTE: This is a shallow calculation (does not take patterns into account),\n  //   so this method should only really be called for special conditions\n  //   where absolute accuracy is not necessarily needed\n  rangeShallowIntersectingRange(date1, date2) {\n    date1 = this.toDateInfo(date1);\n    date2 = this.toDateInfo(date2);\n    if (!this.dateShallowIntersectsDate(date1, date2)) {\n      return null;\n    }\n    const thisRange = date1.toRange();\n    const otherRange = date2.toRange();\n    // Start with infinite start and end dates\n    let start = null;\n    let end = null;\n    // This start date exists\n    if (thisRange.start) {\n      // Use this definite start date if other start date is infinite\n      if (!otherRange.start) {\n        start = thisRange.start;\n      } else {\n        // Otherwise, use the latest start date\n        start =\n          thisRange.start > otherRange.start\n            ? thisRange.start\n            : otherRange.start;\n      }\n      // Other start date exists\n    } else if (otherRange.start) {\n      // Use other definite start date as this one is infinite\n      start = otherRange.start;\n    }\n    // This end date exists\n    if (thisRange.end) {\n      // Use this definite end date if other end date is infinite\n      if (!otherRange.end) {\n        end = thisRange.end;\n      } else {\n        // Otherwise, use the earliest end date\n        end = thisRange.end < otherRange.end ? thisRange.end : otherRange.end;\n      }\n      // Other end date exists\n    } else if (otherRange.end) {\n      // Use other definite end date as this one is infinite\n      end = otherRange.end;\n    }\n    // Return calculated range\n    return { start, end };\n  }\n\n  // ========================================================\n  // Determines if this date partially intersects another date\n  // NOTE: This is a deep test (patterns tested)\n  intersectsDate(other) {\n    const date = this.toDateInfo(other);\n    if (!this.shallowIntersectsDate(date)) return null;\n    if (!this.on) return this;\n    const range = this.rangeShallowIntersectingRange(this, date);\n    let result = false;\n    this.iterateDatesInRange(range, state => {\n      if (this.matchesDay(state.day)) {\n        result = result || date.matchesDay(state.day);\n        state.finished = result;\n      }\n    });\n    return result;\n  }\n\n  // ========================================================\n  // Determines if this date partially intersects another date\n  // NOTE: This is a shallow test (no patterns tested)\n  shallowIntersectsDate(other) {\n    return this.dateShallowIntersectsDate(this, this.toDateInfo(other));\n  }\n\n  // ========================================================\n  // Determines if first date partially intersects second date\n  // NOTE: This is a shallow test (no patterns tested)\n  dateShallowIntersectsDate(date1, date2) {\n    if (date1.isDate) {\n      return date2.isDate\n        ? date1.dateTime === date2.dateTime\n        : this.dateShallowIncludesDate(date2, date1);\n    }\n    if (date2.isDate) {\n      return this.dateShallowIncludesDate(date1, date2);\n    }\n    // Both ranges\n    if (date1.start && date2.end && date1.start > date2.end) {\n      return false;\n    }\n    if (date1.end && date2.start && date1.end < date2.start) {\n      return false;\n    }\n    return true;\n  }\n\n  // ========================================================\n  // Determines if this date completely includes another date\n  // NOTE: This is a deep test (patterns tested)\n  includesDate(other) {\n    const date = this.toDateInfo(other);\n    if (!this.shallowIncludesDate(date)) {\n      return false;\n    }\n    if (!this.on) {\n      return true;\n    }\n    const range = this.rangeShallowIntersectingRange(this, date);\n    let result = true;\n    this.iterateDatesInRange(range, state => {\n      if (this.matchesDay(state.day)) {\n        result = result && date.matchesDay(state.day);\n        state.finished = !result;\n      }\n    });\n    return result;\n  }\n\n  // ========================================================\n  // Determines if this date completely includes another date\n  // NOTE: This is a shallow test (no patterns tested)\n  shallowIncludesDate(other) {\n    return this.dateShallowIncludesDate(\n      this,\n      other.isDate ? other : new DateInfo(other, this.opts),\n    );\n  }\n\n  // ========================================================\n  // Determines if first date completely includes second date\n  // NOTE: This is a shallow test (no patterns tested)\n  dateShallowIncludesDate(date1, date2) {\n    // First date is simple date\n    if (date1.isDate) {\n      if (date2.isDate) {\n        return date1.dateTime === date2.dateTime;\n      }\n      if (!date2.startTime || !date2.endTime) {\n        return false;\n      }\n      return (\n        date1.dateTime === date2.startTime && date1.dateTime === date2.endTime\n      );\n    }\n    // Second date is simple date and first is date range\n    if (date2.isDate) {\n      if (date1.start && date2.date < date1.start) {\n        return false;\n      }\n      if (date1.end && date2.date > date1.end) {\n        return false;\n      }\n      return true;\n    }\n    // Both dates are date ranges\n    if (date1.start && (!date2.start || date2.start < date1.start)) {\n      return false;\n    }\n    if (date1.end && (!date2.end || date2.end > date1.end)) {\n      return false;\n    }\n    return true;\n  }\n\n  includesDay(day) {\n    // Date is outside general range - return null\n    if (!this.shallowIncludesDate(day.date)) return null;\n    // Return this date if patterns match\n    return this.matchesDay(day) ? this : null;\n  }\n\n  matchesDay(day) {\n    // No patterns to test\n    if (!this.on) return true;\n    // Fail if 'and' condition fails\n    if (this.on.and && !DateInfo.testConfig(this.on.and, day, this)) {\n      return false;\n    }\n    // Fail if every 'or' condition fails\n    if (\n      this.on.or &&\n      !this.on.or.some(or => DateInfo.testConfig(or, day, this))\n    ) {\n      return false;\n    }\n    // Patterns match\n    return true;\n  }\n\n  toRange() {\n    if (this.isDate) {\n      return new DateInfo(\n        {\n          start: this.date,\n          end: this.date,\n        },\n        this.opts,\n      );\n    }\n    return new DateInfo(\n      {\n        start: this.start,\n        end: this.end,\n      },\n      this.opts,\n    );\n  }\n\n  // Build the 'compare to other' function\n  compare(other) {\n    if (this.order !== other.order) return this.order - other.order;\n    if (this.type !== other.type) return this.isDate ? 1 : -1;\n    if (this.isDate) return 0;\n    const diff = this.start - other.start;\n    return diff !== 0 ? diff : this.end - other.end;\n  }\n}\n"]}]}