{"remainingRequest":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/thread-loader/dist/cjs.js!/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/babel-loader/lib/index.js!/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/cache-loader/dist/cjs.js??ref--0-0!/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/guest/Ostanin-dev/static/lib/v-calendar/src/components/Grid.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/src/components/Grid.vue","mtime":1592351795000},{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/guest/Ostanin-dev/static/lib/v-calendar/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["const directions = {\n  vLeading: 'vertical-leading',\n  vTrailing: 'vertical-trailing',\n  hLeading: 'horizontal-leading',\n  hTrailing: 'horizontal-trailing'\n};\nexport default {\n  name: 'Grid',\n\n  render(h) {\n    // Grid cell renderer\n    const getCell = ({\n      nodes,\n      position,\n      row,\n      column\n    }) => {\n      // Get the default slot first\n      if (nodes.length >= position) {\n        return nodes[position - 1];\n      } // Get the scoped slot second\n\n\n      if (this.$scopedSlots.default) {\n        return this.$scopedSlots.default({\n          position,\n          row,\n          column\n        });\n      }\n\n      return null;\n    }; // Grid cells renderer\n\n\n    const getCells = () => {\n      const cells = []; // Resolve default slot nodes (remove whitespaced)\n\n      const nodes = this.$slots.default && this.$slots.default.filter(n => n.tag !== undefined) || []; // Build cells\n\n      for (let r = 1, p = 1; r <= this.rows; r++) {\n        for (let c = 1; c <= this.columns; c++) {\n          const rFromEnd = r - this.rows - 1;\n          const cFromEnd = c - this.columns - 1; // Add the cell for current row & column\n\n          cells.push(h('div', {\n            class: ['vc-grid-cell', `vc-grid-cell-row-${r}`, `vc-grid-cell-row-${rFromEnd}`, `vc-grid-cell-col-${c}`, `vc-grid-cell-col-${cFromEnd}`],\n            style: {\n              'grid-row': r,\n              'grid-column': c\n            },\n            on: {\n              keydown: e => this.handleCellKeydown({\n                row: r,\n                column: c,\n                event: e\n              })\n            }\n          }, [getCell({\n            nodes,\n            position: p++,\n            row: r,\n            column: c\n          })]));\n        }\n      }\n\n      return cells;\n    };\n\n    return h('div', {\n      class: 'vc-grid-container',\n      style: this.containerStyle\n    }, [...getCells()]);\n  },\n\n  props: {\n    count: Number,\n    rows: {\n      type: Number,\n      default: 1\n    },\n    columns: {\n      type: Number,\n      default: 1\n    },\n    gap: {\n      type: String,\n      default: '0px'\n    },\n    autofit: Boolean,\n    columnWidth: {\n      type: String,\n      default: '1fr'\n    },\n    disableFocus: {\n      type: Boolean,\n      default: false\n    }\n  },\n  computed: {\n    containerStyle() {\n      return {\n        gridTemplateColumns: this.gridTemplateColumns,\n        gridGap: this.gap\n      };\n    },\n\n    gridTemplateColumns() {\n      return `repeat(${this.autofit ? 'auto-fit' : this.columns}, ${this.columnWidth})`;\n    }\n\n  },\n  methods: {\n    handleCellKeydown({\n      row,\n      column,\n      event\n    }) {\n      // Return if focus management is disabled\n      if (this.disableFocus) return;\n      const state = {\n        row,\n        column,\n        alt: false,\n        handled: false\n      }; // Increment row/column based on key\n\n      switch (event.key) {\n        case 'ArrowUp':\n          {\n            state.row--;\n            break;\n          }\n\n        case 'ArrowDown':\n          {\n            state.row++;\n            break;\n          }\n\n        case 'ArrowLeft':\n          {\n            state.column--;\n            break;\n          }\n\n        case 'ArrowRight':\n          {\n            state.column++;\n            break;\n          }\n\n        case 'Home':\n          {\n            state.column = 1;\n            break;\n          }\n\n        case 'End':\n          {\n            state.column = this.columns;\n            break;\n          }\n\n        case 'PageUp':\n          {\n            state.alt = event.altKey;\n            state.direction = directions.vLeading;\n            break;\n          }\n\n        case 'PageDown':\n          {\n            state.alt = event.altKey;\n            state.direction = directions.vTrailing;\n            break;\n          }\n\n        default:\n          {\n            return;\n          }\n      } // Handle state for row rollovers\n\n\n      if (state.row < 1) {\n        state.direction = directions.vLeading;\n        state.row = this.rows;\n      } else if (state.row > this.rows) {\n        state.direction = directions.vTrailing;\n        state.row = 1;\n      } // Handle state for column rollovers\n\n\n      if (state.column < 1) {\n        state.direction = directions.hLeading;\n        state.column = this.columns;\n      } else if (state.column > this.columns) {\n        state.direction = directions.hTrailing;\n        state.column = 1;\n      } // Emit rollover event if direction was assigned\n\n\n      if (state.direction) {\n        this.$emit('rollover', state);\n      } // Focusd on cell for current state if event wasn't handled\n\n\n      if (!state.handled) {\n        // Get grid cell element\n        const cellSelector = `.vc-grid-cell-row-${state.row}.vc-grid-cell-col-${state.column}`;\n        const cellEl = this.$el.querySelector(cellSelector);\n\n        if (cellEl) {\n          this.tryFocus(cellEl);\n        }\n      }\n\n      event.stopPropagation();\n      event.preventDefault();\n    },\n\n    tryFocus(el = this.$el) {\n      this.$nextTick(() => {\n        const selectors = ['.vc-grid-focus', 'button, [href], input, select, textarea, [tabindex=\"0\"]', '[tabindex]:not([tabindex=\"undefined\"])'];\n        const focusableEl = selectors.map(s => el.querySelector(s)).find(e => e);\n\n        if (focusableEl) {\n          focusableEl.focus();\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n  }\n};",{"version":3,"sources":["Grid.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\nconst directions = {\n  vLeading: 'vertical-leading',\n  vTrailing: 'vertical-trailing',\n  hLeading: 'horizontal-leading',\n  hTrailing: 'horizontal-trailing',\n};\nexport default {\n  name: 'Grid',\n  render(h) {\n    // Grid cell renderer\n    const getCell = ({ nodes, position, row, column }) => {\n      // Get the default slot first\n      if (nodes.length >= position) {\n        return nodes[position - 1];\n      }\n      // Get the scoped slot second\n      if (this.$scopedSlots.default) {\n        return this.$scopedSlots.default({\n          position,\n          row,\n          column,\n        });\n      }\n      return null;\n    };\n\n    // Grid cells renderer\n    const getCells = () => {\n      const cells = [];\n      // Resolve default slot nodes (remove whitespaced)\n      const nodes =\n        (this.$slots.default &&\n          this.$slots.default.filter(n => n.tag !== undefined)) ||\n        [];\n      // Build cells\n      for (let r = 1, p = 1; r <= this.rows; r++) {\n        for (let c = 1; c <= this.columns; c++) {\n          const rFromEnd = r - this.rows - 1;\n          const cFromEnd = c - this.columns - 1;\n          // Add the cell for current row & column\n          cells.push(\n            h(\n              'div',\n              {\n                class: [\n                  'vc-grid-cell',\n                  `vc-grid-cell-row-${r}`,\n                  `vc-grid-cell-row-${rFromEnd}`,\n                  `vc-grid-cell-col-${c}`,\n                  `vc-grid-cell-col-${cFromEnd}`,\n                ],\n                style: {\n                  'grid-row': r,\n                  'grid-column': c,\n                },\n                on: {\n                  keydown: e =>\n                    this.handleCellKeydown({ row: r, column: c, event: e }),\n                },\n              },\n              [getCell({ nodes, position: p++, row: r, column: c })],\n            ),\n          );\n        }\n      }\n      return cells;\n    };\n\n    return h(\n      'div',\n      {\n        class: 'vc-grid-container',\n        style: this.containerStyle,\n      },\n      [...getCells()],\n    );\n  },\n  props: {\n    count: Number,\n    rows: {\n      type: Number,\n      default: 1,\n    },\n    columns: {\n      type: Number,\n      default: 1,\n    },\n    gap: {\n      type: String,\n      default: '0px',\n    },\n    autofit: Boolean,\n    columnWidth: {\n      type: String,\n      default: '1fr',\n    },\n    disableFocus: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  computed: {\n    containerStyle() {\n      return {\n        gridTemplateColumns: this.gridTemplateColumns,\n        gridGap: this.gap,\n      };\n    },\n    gridTemplateColumns() {\n      return `repeat(${this.autofit ? 'auto-fit' : this.columns}, ${\n        this.columnWidth\n      })`;\n    },\n  },\n  methods: {\n    handleCellKeydown({ row, column, event }) {\n      // Return if focus management is disabled\n      if (this.disableFocus) return;\n      const state = {\n        row,\n        column,\n        alt: false,\n        handled: false,\n      };\n      // Increment row/column based on key\n      switch (event.key) {\n        case 'ArrowUp': {\n          state.row--;\n          break;\n        }\n        case 'ArrowDown': {\n          state.row++;\n          break;\n        }\n        case 'ArrowLeft': {\n          state.column--;\n          break;\n        }\n        case 'ArrowRight': {\n          state.column++;\n          break;\n        }\n        case 'Home': {\n          state.column = 1;\n          break;\n        }\n        case 'End': {\n          state.column = this.columns;\n          break;\n        }\n        case 'PageUp': {\n          state.alt = event.altKey;\n          state.direction = directions.vLeading;\n          break;\n        }\n        case 'PageDown': {\n          state.alt = event.altKey;\n          state.direction = directions.vTrailing;\n          break;\n        }\n        default: {\n          return;\n        }\n      }\n      // Handle state for row rollovers\n      if (state.row < 1) {\n        state.direction = directions.vLeading;\n        state.row = this.rows;\n      } else if (state.row > this.rows) {\n        state.direction = directions.vTrailing;\n        state.row = 1;\n      }\n      // Handle state for column rollovers\n      if (state.column < 1) {\n        state.direction = directions.hLeading;\n        state.column = this.columns;\n      } else if (state.column > this.columns) {\n        state.direction = directions.hTrailing;\n        state.column = 1;\n      }\n      // Emit rollover event if direction was assigned\n      if (state.direction) {\n        this.$emit('rollover', state);\n      }\n      // Focusd on cell for current state if event wasn't handled\n      if (!state.handled) {\n        // Get grid cell element\n        const cellSelector = `.vc-grid-cell-row-${state.row}.vc-grid-cell-col-${state.column}`;\n        const cellEl = this.$el.querySelector(cellSelector);\n        if (cellEl) {\n          this.tryFocus(cellEl);\n        }\n      }\n      event.stopPropagation();\n      event.preventDefault();\n    },\n    tryFocus(el = this.$el) {\n      this.$nextTick(() => {\n        const selectors = [\n          '.vc-grid-focus',\n          'button, [href], input, select, textarea, [tabindex=\"0\"]',\n          '[tabindex]:not([tabindex=\"undefined\"])',\n        ];\n        const focusableEl = selectors\n          .map(s => el.querySelector(s))\n          .find(e => e);\n        if (focusableEl) {\n          focusableEl.focus();\n          return true;\n        }\n        return false;\n      });\n    },\n  },\n};\n</script>\n\n<style scoped>\n.vc-grid-container {\n  position: relative;\n  flex-shrink: 1;\n  display: grid;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\n.vc-grid-cell {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n</style>\n"],"sourceRoot":"src/components"}]}