{"id":"onOW","dependencies":[{"name":"/home/guest/package.json","includedInParent":true,"mtime":1602577164900},{"name":"nano-md5","loc":{"line":418,"column":19},"parent":"/home/guest/Ostanin-dev/static/js/svelte-auth/dist/index.mjs","resolved":"/home/guest/Ostanin-dev/static/js/svelte-auth/node_modules/nano-md5/md5.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction noop() {}\n\nfunction run(fn) {\n  return fn();\n}\n\nfunction blank_object() {\n  return Object.create(null);\n}\n\nfunction run_all(fns) {\n  fns.forEach(run);\n}\n\nfunction is_function(thing) {\n  return typeof thing === 'function';\n}\n\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n}\n\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\n\nfunction append(target, node) {\n  target.appendChild(node);\n}\n\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\n\nfunction detach(node) {\n  node.parentNode.removeChild(node);\n}\n\nfunction element(name) {\n  return document.createElement(name);\n}\n\nfunction text(data) {\n  return document.createTextNode(data);\n}\n\nfunction space() {\n  return text(' ');\n}\n\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return function () {\n    return node.removeEventListener(event, handler, options);\n  };\n}\n\nfunction attr(node, attribute, value) {\n  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\n\nfunction set_input_value(input, value) {\n  input.value = value == null ? '' : value;\n}\n\nvar current_component;\n\nfunction set_current_component(component) {\n  current_component = component;\n}\n\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = Promise.resolve();\nvar update_scheduled = false;\n\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\n\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\n\nvar flushing = false;\nvar seen_callbacks = new Set();\n\nfunction flush() {\n  if (flushing) return;\n  flushing = true;\n\n  do {\n    // first, call beforeUpdate functions\n    // and update components\n    for (var i = 0; i < dirty_components.length; i += 1) {\n      var component = dirty_components[i];\n      set_current_component(component);\n      update(component.$$);\n    }\n\n    set_current_component(null);\n    dirty_components.length = 0;\n\n    while (binding_callbacks.length) {\n      binding_callbacks.pop()();\n    } // then, once components are updated, call\n    // afterUpdate functions. This may cause\n    // subsequent updates...\n\n\n    for (var _i = 0; _i < render_callbacks.length; _i += 1) {\n      var callback = render_callbacks[_i];\n\n      if (!seen_callbacks.has(callback)) {\n        // ...so guard against infinite loops\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n\n  update_scheduled = false;\n  flushing = false;\n  seen_callbacks.clear();\n}\n\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    var dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\n\nvar outroing = new Set();\n\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\n\nfunction mount_component(component, target, anchor) {\n  var _component$$$ = component.$$,\n      fragment = _component$$$.fragment,\n      on_mount = _component$$$.on_mount,\n      on_destroy = _component$$$.on_destroy,\n      after_update = _component$$$.after_update;\n  fragment && fragment.m(target, anchor); // onMount happens before the initial afterUpdate\n\n  add_render_callback(function () {\n    var new_on_destroy = on_mount.map(run).filter(is_function);\n\n    if (on_destroy) {\n      on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));\n    } else {\n      // Edge case - component was destroyed immediately,\n      // most likely as a result of a binding initialising\n      run_all(new_on_destroy);\n    }\n\n    component.$$.on_mount = [];\n  });\n  after_update.forEach(add_render_callback);\n}\n\nfunction destroy_component(component, detaching) {\n  var $$ = component.$$;\n\n  if ($$.fragment !== null) {\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to\n    // preserve final state?)\n\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\n\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\n\nfunction init(component, options, instance, create_fragment, not_equal, props) {\n  var dirty = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [-1];\n  var parent_component = current_component;\n  set_current_component(component);\n  var prop_values = options.props || {};\n  var $$ = component.$$ = {\n    fragment: null,\n    ctx: null,\n    // state\n    props: props,\n    update: noop,\n    not_equal: not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(parent_component ? parent_component.$$.context : []),\n    // everything else\n    callbacks: blank_object(),\n    dirty: dirty,\n    skip_bound: false\n  };\n  var ready = false;\n  $$.ctx = instance ? instance(component, prop_values, function (i, ret) {\n    var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n      if (ready) make_dirty(component, i);\n    }\n\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update); // `false` as a special case of no DOM component\n\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\n  if (options.target) {\n    if (options.hydrate) {\n      var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      $$.fragment && $$.fragment.c();\n    }\n\n    if (options.intro) transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor);\n    flush();\n  }\n\n  set_current_component(parent_component);\n}\n\nvar SvelteComponent = /*#__PURE__*/function () {\n  function SvelteComponent() {\n    _classCallCheck(this, SvelteComponent);\n  }\n\n  _createClass(SvelteComponent, [{\n    key: \"$destroy\",\n    value: function $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n  }, {\n    key: \"$on\",\n    value: function $on(type, callback) {\n      var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return function () {\n        var index = callbacks.indexOf(callback);\n        if (index !== -1) callbacks.splice(index, 1);\n      };\n    }\n  }, {\n    key: \"$set\",\n    value: function $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  }]);\n\n  return SvelteComponent;\n}(); // Example POST method implementation:\n\n/*async*/\n\n\nfunction postJSON() {\n  var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // Default options are marked with *\n\n  /*  const response = await*/\n  return fetch(url, {\n    method: 'POST',\n    // *GET, POST, PUT, DELETE, etc.\n    mode: 'cors',\n    // no-cors, *cors, same-origin\n    cache: 'no-cache',\n    // *default, no-cache, reload, force-cache, only-if-cached\n    credentials: 'same-origin',\n    // include, *same-origin, omit\n    headers: {\n      'Content-Type': 'application/json' // 'Content-Type': 'application/x-www-form-urlencoded',\n\n    },\n    //~ redirect: 'follow', // manual, *follow, error\n    //~ referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url\n    body: JSON.stringify(data) // body data type must match \"Content-Type\" header\n\n  }).then(function (res) {\n    return res.json();\n  }); //~ return response.json(); // parses JSON response into native JavaScript objects\n}\n\nvar Http = {\n  \"post\": postJSON\n};\n/* src/Component.svelte generated by Svelte v3.29.0 */\n\nfunction create_fragment(ctx) {\n  var div8;\n  var div7;\n  var div5;\n  var h2;\n  var t1;\n  var h40;\n  var t3;\n  var div2;\n  var div0;\n  var input0;\n  var t4;\n  var h41;\n  var t6;\n  var div1;\n  var input1;\n  var t7;\n  var div3;\n  var t9;\n  var div4;\n  var t10;\n  var div6;\n  var a;\n  var mounted;\n  var dispose;\n  return {\n    c: function c() {\n      div8 = element(\"div\");\n      div7 = element(\"div\");\n      div5 = element(\"div\");\n      h2 = element(\"h2\");\n      h2.innerHTML = \"<i class=\\\"icon-login\\\"></i>\\n      \\u0412\\u0445\\u043E\\u0434 \\u0432 \\u0441\\u0438\\u0441\\u0442\\u0435\\u043C\\u0443\";\n      t1 = space();\n      h40 = element(\"h4\");\n      h40.textContent = \"Логин\";\n      t3 = space();\n      div2 = element(\"div\");\n      div0 = element(\"div\");\n      input0 = element(\"input\");\n      t4 = space();\n      h41 = element(\"h4\");\n      h41.textContent = \"Пароль\";\n      t6 = space();\n      div1 = element(\"div\");\n      input1 = element(\"input\");\n      t7 = space();\n      div3 = element(\"div\");\n      div3.innerHTML = \"<h5>\\u041F\\u0440\\u043E\\u0432\\u0435\\u0440\\u044C\\u0442\\u0435 \\u043B\\u043E\\u0433\\u0438\\u043D/\\u043F\\u0430\\u0440\\u043E\\u043B\\u044C \\u0434\\u043B\\u044F \\u0432\\u0445\\u043E\\u0434\\u0430</h5>\";\n      t9 = space();\n      div4 = element(\"div\");\n      t10 = space();\n      div6 = element(\"div\");\n      a = element(\"a\");\n      a.innerHTML = \"<i class=\\\"icon-login\\\"></i>\";\n      attr(h2, \"class\", \"center\");\n      attr(input0, \"name\", \"login\");\n      attr(input0, \"type\", \"text\");\n      attr(input0, \"class\", \"\");\n      input0.required = true;\n      attr(input0, \"placeholder\", \"имя или телефон\");\n      attr(div0, \"class\", \"input-field\");\n      attr(input1, \"name\", \"passwd\");\n      attr(input1, \"type\", \"password\");\n      attr(input1, \"class\", \"validate\");\n      input1.required = true;\n      attr(input1, \"placeholder\", \"**********\");\n      attr(div1, \"ng-show\", \"!$c.forget && !$c.remem\");\n      attr(div1, \"class\", \"input-field\");\n      attr(div2, \"class\", \"input-fields\");\n      attr(div3, \"class\", \"\");\n      attr(div3, \"ng-if\", \"!$c.remem && !$c.forget && $c.captcha\");\n      attr(div4, \"ng-show\", \"$c.cancelerHttp\");\n      attr(div4, \"ng-include\", \" 'progress/check' \");\n      attr(div5, \"class\", \"card-content\");\n      attr(a, \"id\", \"btnSaveNames\");\n      attr(a, \"class\", \"btn-floating-000 btn-large\");\n      attr(a, \"href\", \"javascript:\");\n      attr(a, \"ng-class\", \"disabled: !$c.Validate()\");\n      attr(div6, \"class\", \"card-action center\");\n      attr(div7, \"class\", \"card teal lighten-5 animated-000-slideInUp\");\n    },\n    m: function m(target, anchor) {\n      insert(target, div8, anchor);\n      append(div8, div7);\n      append(div7, div5);\n      append(div5, h2);\n      append(div5, t1);\n      append(div5, h40);\n      append(div5, t3);\n      append(div5, div2);\n      append(div2, div0);\n      append(div0, input0);\n      set_input_value(input0,\n      /*login*/\n      ctx[0]);\n      append(div2, t4);\n      append(div2, h41);\n      append(div2, t6);\n      append(div2, div1);\n      append(div1, input1);\n      set_input_value(input1,\n      /*passwd*/\n      ctx[1]);\n      append(div5, t7);\n      append(div5, div3);\n      append(div5, t9);\n      append(div5, div4);\n      append(div7, t10);\n      append(div7, div6);\n      append(div6, a);\n\n      if (!mounted) {\n        dispose = [listen(input0, \"input\",\n        /*input0_input_handler*/\n        ctx[5]), listen(input0, \"keypress\",\n        /*EnterSend*/\n        ctx[2]), listen(input1, \"input\",\n        /*input1_input_handler*/\n        ctx[6]), listen(input1, \"keypress\",\n        /*EnterSend*/\n        ctx[2]), listen(a, \"click\",\n        /*Send*/\n        ctx[3])];\n        mounted = true;\n      }\n    },\n    p: function p(ctx, _ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          dirty = _ref2[0];\n\n      if (dirty &\n      /*login*/\n      1 && input0.value !==\n      /*login*/\n      ctx[0]) {\n        set_input_value(input0,\n        /*login*/\n        ctx[0]);\n      }\n\n      if (dirty &\n      /*passwd*/\n      2 && input1.value !==\n      /*passwd*/\n      ctx[1]) {\n        set_input_value(input1,\n        /*passwd*/\n        ctx[1]);\n      }\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(div8);\n      mounted = false;\n      run_all(dispose);\n    }\n  };\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n  var md5 = require(\"nano-md5\");\n\n  var login = \"\";\n  var passwd = \"\";\n  var successCallback = $$props.successCallback;\n\n  var appRoutes = function appRoutes() {\n    return angular.injector([\"AppRoutes\"]).get(\"appRoutes\");\n  };\n\n  var EnterSend = function EnterSend() {\n    console.log(\"EnterSend\");\n  };\n\n  var Send = function Send() {\n    Http.post(appRoutes().urlFor(\"обычная авторизация/регистрация\"), {\n      login: login,\n      \"passwd\": md5(passwd)\n    }).then(function (data) {\n      if (data.id) {\n        //успешный вход\n        Materialize.Toast(\"Успешный вход\", 3000, \"green lighten-4 green-text text-darken-4 border fw500 animated zoomInUp\");\n        if (successCallback) return successCallback(data);\n        window.location.href = \"/\";\n      }\n    });\n  }; //~     \n\n\n  function input0_input_handler() {\n    login = this.value;\n    $$invalidate(0, login);\n  }\n\n  function input1_input_handler() {\n    passwd = this.value;\n    $$invalidate(1, passwd);\n  }\n\n  $$self.$$set = function ($$props) {\n    if (\"successCallback\" in $$props) $$invalidate(4, successCallback = $$props.successCallback);\n  };\n\n  return [login, passwd, EnterSend, Send, successCallback, input0_input_handler, input1_input_handler];\n}\n\nvar Component = /*#__PURE__*/function (_SvelteComponent) {\n  _inherits(Component, _SvelteComponent);\n\n  var _super = _createSuper(Component);\n\n  function Component(options) {\n    var _this;\n\n    _classCallCheck(this, Component);\n\n    _this = _super.call(this);\n    init(_assertThisInitialized(_this), options, instance, create_fragment, safe_not_equal, {\n      successCallback: 4\n    });\n    return _this;\n  }\n\n  return Component;\n}(SvelteComponent);\n\nvar _default = Component;\nexports.default = _default;"},"sourceMaps":null,"error":null,"hash":"34b77069e50be79254d7a5d4aa78e045","cacheData":{"env":{}}}